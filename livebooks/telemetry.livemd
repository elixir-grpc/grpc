# Telemetry

```elixir
my_app_root = Path.join(__DIR__, "..")

Mix.install(
  [
    {:grpc, path: my_app_root, env: :dev},
    {:telemetry_metrics, "~> 0.6"},
    {:telemetry_metrics_prometheus, "~> 1.1"},
    {:req, "~> 0.3"}
  ],
  config_path: Path.join(my_app_root, "config/config.exs"),
  lockfile: Path.join(my_app_root, "mix.lock")
)
```

## Telemetry Events

We know from the documentation `GRPC.Telemetry` that some server-side events and some client-side events are published. We can use those events to build a Prometheus metrics export through `Telemetry.Metrics` and [`TelemetryMetricsPrometheus`](https://hexdocs.pm/telemetry_metrics_prometheus/TelemetryMetricsPrometheus.html) that's retrocompatible to the deprecated `:grpc_prometheus` library.

First, let's create a mock server and client that we can use.

## GRPC Server and Client

```elixir
# This whole code block is taken from test/support/proto/helloword.pb.ex
# Normally, this would be autogenerated from a valid protobuf file,
# but we're using this hardcoded version so that this Livebook is self-contained.

defmodule Helloworld.HelloRequest do
  @moduledoc false
  use Protobuf, protoc_gen_elixir_version: "0.11.0", syntax: :proto3

  field(:name, 1, type: :string)
  field(:duration, 2, proto3_optional: true, type: :int32)
end

defmodule Helloworld.HelloReply do
  @moduledoc false
  use Protobuf, protoc_gen_elixir_version: "0.11.0", syntax: :proto3

  field(:message, 1, type: :string)
end

defmodule Helloworld.HeaderRequest do
  @moduledoc false
  use Protobuf, protoc_gen_elixir_version: "0.11.0", syntax: :proto3
end

defmodule Helloworld.HeaderReply do
  @moduledoc false
  use Protobuf, protoc_gen_elixir_version: "0.11.0", syntax: :proto3

  field(:authorization, 1, type: :string)
end

defmodule Helloworld.Greeter.Service do
  @moduledoc false
  use GRPC.Service, name: "helloworld.Greeter", protoc_gen_elixir_version: "0.11.0"

  rpc(:SayHello, Helloworld.HelloRequest, Helloworld.HelloReply)

  rpc(:CheckHeaders, Helloworld.HeaderRequest, Helloworld.HeaderReply)
end

defmodule Helloworld.Greeter.Stub do
  @moduledoc false
  use GRPC.Stub, service: Helloworld.Greeter.Service
end
```

```elixir
defmodule HelloServer do
  use GRPC.Server, service: Helloworld.Greeter.Service

  def say_hello(%{name: "raise", duration: duration}, _stream) do
    Process.sleep(duration)
    raise ArgumentError, "exception raised"
  end

  def say_hello(%{name: "ok", duration: duration}, _stream) do
    Process.sleep(duration)
    Helloworld.HelloReply.new(message: "Hello")
  end

  def check_headers(_req, stream) do
    token = GRPC.Stream.get_headers(stream)["authorization"]
    Helloworld.HeaderReply.new(authorization: token)
  end
end
```

```elixir
defmodule MetricsSupervisor do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  defp is_message(stream) do
    stream.grpc_type in [:client_stream, :bidi_stream]
  end

  def init(_arg) do
    # We attach to these events to combine them into a single published metric
    # This can actually be done directly in Prometheus through Recording Rules,
    # but this shows how to build a drop-in replacement for :grpc_prometheus
    :telemetry.attach_many(
      "handler-#{__MODULE__}",
      [
        [:grpc, :server, :rpc, :stop],
        [:grpc, :server, :rpc, :exception]
      ],
      fn _event, %{duration: duration}, %{stream: stream}, _opts ->
        # TO-DO: change to a check on whether the request is a message
        if is_message(stream) do
          :telemetry.execute([:custom_grpc, :server_rpc, :sent], %{duration: duration})
        end

        :telemetry.execute([:custom_grpc, :server_rpc, :handled], %{duration: duration})
      end,
      nil
    )

    :telemetry.attach(
      "handler-#{__MODULE__}-start",
      [:grpc, :server, :rpc, :start],
      fn _event, _, %{stream: stream}, _opts ->
        if is_message(stream) do
          :telemetry.execute([:custom_grpc, :server_rpc, :message_received], %{count: 1})
        end
      end,
      nil
    )

    children = [
      {TelemetryMetricsPrometheus, [metrics: metrics(), port: 9568]}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  @histogram_buckets_seconds [5.0e-3, 10.0e-3, 25.0e-3, 50.0e-3, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]

  defp metrics do
    [
      # Server Metrics
      counter(
        "grpc_server_started_total",
        event_name: "grpc.server.rpc.start",
        measurement: :count,
        description: "Total number of RPCs started on the server"
      ),
      counter(
        "grpc_server_msg_received_total",
        event_name: "custom_grpc.server_rpc.message_received",
        measurement: :count,
        description: "Total number of RPC stream messages received on the server"
      ),
      counter(
        "grpc_server_msg_sent_total",
        event_name: "custom_grpc.server_rpc.sent",
        measurement: :duration,
        description: "Total number of gRPC stream messages sent by the server."
      ),
      counter(
        "grpc_server_handled_total",
        event_name: "custom_grpc.server_rpc.handled",
        measurement: :duration,
        description:
          "Total number of RPCs completed on the server, regardless of success or failure."
      ),
      histogram(
        "grpc_server_handled_latency_seconds",
        event_name: "custom_grpc.server_rpc.handled",
        description: "Histogram of response latency of rpcs handled by the server, in seconds.",
        measurement: :duration,
        buckets: @histogram_buckets_seconds,
        unit: {:native, :seconds}
      )

      # Client Metrics
    ]
  end
end
```

```elixir
{:ok, pid} = MetricsSupervisor.start_link([])
```

```elixir
# Checking which metrics our endpoint returns
:telemetry.execute([:grpc, :server, :rpc, :start], %{count: 1})
{:ok, %Req.Response{status: 200, body: body}} = Req.request(url: "http://localhost:9568/metrics")

# Print the output in a readable format
IO.puts(body)
nil
```
